#ifndef TOKENIZER_H
#define TOKENIZER_H

#include "util/File.h"

#include <vector>
#include <string>
#include <unordered_map>
#include <set>


// TODO create a macro that will generate the token spec
class Tokenizer {
    public:
        enum Type {
            UNKNOWN,

            TEXT, WHITESPACE_SPACE, WHITESPACE_TAB, WHITESPACE_NEWLINE, WHITESPACE,
            COMMENT_SINGLE_LINE, COMMENT_MULTI_LINE, BACK_SLASH, FORWARD_SLASH,

            // PREPROCESSOR DIRECTIVES
            PREPROCESSOR_INCLUDE,
            PREPROCESSOR_MACRO, PREPROCESSOR_MACRET, PREPROCESSOR_MACEND, PREPROCESSOR_INVOKE,
            PREPROCESSOR_DEFINE, PREPROCESSOR_UNDEF,
            PREPROCESSOR_IFDEF, PREPROCESSOR_IFNDEF,
            PREPROCESSOR_IFEQU, PREPROCESSOR_IFNEQU, PREPROCESSOR_IFLESS, PREPROCESSOR_IFMORE,
            PREPROCESSOR_ELSE, PREPROCESSOR_ELSEDEF, PREPROCESSOR_ELSENDEF,
            PREPROCESSOR_ELSEEQU, PREPROCESSOR_ELSENEQU, PREPROCESSOR_ELSELESS, PREPROCESSOR_ELSEMORE,
            PREPROCESSOR_ENDIF,

            // VARIABLE TYPES
            VARIABLE_TYPE_BYTE, VARIABLE_TYPE_DBYTE, VARIABLE_TYPE_WORD, VARIABLE_TYPE_DWORD,
            VARIABLE_TYPE_CHAR, VARIABLE_TYPE_STRING, VARIABLE_TYPE_FLOAT, VARIABLE_TYPE_DOUBLE,
            VARIABLE_TYPE_BOOLEAN,

            // ASSEMBLER DIRECTIVES
            ASSEMBLER_GLOBAL, ASSEMBLER_EXTERN,
            ASSEMBLER_EQU,
            ASSEMBLER_ORG,
            ASSEMBLER_SCOPE, ASSEMBLER_SCEND,
            ASSEMBLER_DB_LOW_ENDIAN,
            ASSEMBLER_DDB_LOW_ENDIAN, ASSEMBLER_DDB_HIGH_ENDIAN,
            ASSEMBLER_DW_LOW_ENDIAN, ASSEMBLER_DW_HIGH_ENDIAN,
            ASSEMBLER_DDW_LOW_ENDIAN, ASSEMBLER_DDW_HIGH_ENDIAN,
            ASSEMBLER_ASCII, ASSEMBLER_ASCIZ,
            ASSEMBLER_ADVANCE, ASSEMBLER_FILL, ASSEMBLER_SPACE,
            ASSEMBLER_CHECKPC,
            ASSEMBLER_ALIGN,
            ASSEMBLER_BSS, ASSEMBLER_BSS_ABSOLUTE,
            ASSEMBLER_DATA, ASSEMBLER_DATA_ABSOLUTE,
            ASSEMBLER_TEXT, ASSEMBLER_TEXT_ABSOLUTE,
            ASSEMBLER_STOP,

			// instructions
			INSTRUCTION_ADD, INSTRUCTION_SUB, INSTRUCTION_RSB,
			INSTRUCTION_ADC, INSTRUCTION_SBC, INSTRUCTION_RSC,
			INSTRUCTION_MUL, INSTRUCTION_UMULL, INSTRUCTION_SMULL,
			INSTRUCTION_VABS_F32, INSTRUCTION_VNEG_F32, INSTRUCTION_VSQRT_F32,
			INSTRUCTION_VADD_F32, INSTRUCTION_VSUB_F32, INSTRUCTION_VDIV_F32,
			INSTRUCTION_VMUL_F32, INSTRUCTION_VCMP_F32, INSTRUCTION_VSEL_F32,
			INSTRUCTION_VCINT_U32_F32, INSTRUCTION_VCINT_S32_F32,
			INSTRUCTION_VCFLO_U32_F32, INSTRUCTION_VCFLO_S32_F32,
			INSTRUCTION_VMOV_F32,
			INSTRUCTION_AND, INSTRUCTION_ORR, INSTRUCTION_EOR, INSTRUCTION_BIC,
			INSTRUCTION_LSL, INSTRUCTION_LSR, INSTRUCTION_ASR, INSTRUCTION_ROR,
			INSTRUCTION_CMP, INSTRUCTION_CMN, INSTRUCTION_TST, INSTRUCTION_TEQ,
			INSTRUCTION_MOV, INSTRUCTION_MVN,
			INSTRUCTION_LDR, INSTRUCTION_STR, INSTRUCTION_SWP,
			INSTRUCTION_LDRB, INSTRUCTION_STRB, INSTRUCTION_SWPB,
			INSTRUCTION_LDRH, INSTRUCTION_STRH, INSTRUCTION_SWPH,
			INSTRUCTION_B, INSTRUCTION_BL, INSTRUCTION_BX, INSTRUCTION_BLX, INSTRUCTION_SWI,

			// conditions for branch instructions
			CONDITION_EQ, CONDITION_NE,
			CONDITION_CS, CONDITION_HS,
			CONDITION_CC, CONDITION_LO,
			CONDITION_MI, CONDITION_PL,
			CONDITION_VS, CONDITION_VC,
			CONDITION_HI, CONDITION_LS,
			CONDITION_GE, CONDITION_LT, CONDITION_GT, CONDITION_LE,
			CONDITION_AL, CONDITION_NV,

			// expressions
            NUMBER_SIGN,
			LITERAL_FLOAT_32,
            LITERAL_NUMBER_BINARY, LITERAL_NUMBER_OCTAL, LITERAL_NUMBER_DECIMAL, LITERAL_NUMBER_HEXADECIMAL,
            LITERAL_CHAR, LITERAL_STRING,

            SYMBOL,
            COLON, COMMA, PERIOD, SEMICOLON,
            OPEN_PARANTHESIS, CLOSE_PARANTHESIS, OPEN_BRACKET, CLOSE_BRACKET, OPEN_BRACE, CLOSE_BRACE,

            OPERATOR_ADDITION, OPERATOR_SUBTRACTION, OPERATOR_MULTIPLICATION, OPERATOR_DIVISION, OPERATOR_MODULUS,
            OPERATOR_BITWISE_LEFT_SHIFT, OPERATOR_BITWISE_RIGHT_SHIFT,
            OPERATOR_BITWISE_XOR, OPERATOR_BITWISE_AND, OPERATOR_BITWISE_OR, OPERATOR_BITWISE_COMPLEMENT,
            OPERATOR_LOGICAL_NOT, OPERATOR_LOGICAL_EQUAL, OPERATOR_LOGICAL_NOT_EQUAL,
            OPERATOR_LOGICAL_LESS_THAN, OPERATOR_LOGICAL_GREATER_THAN,
            OPERATOR_LOGICAL_LESS_THAN_OR_EQUAL, OPERATOR_LOGICAL_GREATER_THAN_OR_EQUAL,
            OPERATOR_LOGICAL_OR, OPERATOR_LOGICAL_AND,
        };

        inline static const std::unordered_map<Type, std::string> TYPE_TO_NAME_MAP = {
            {UNKNOWN, "UNKNOWN"},

            {TEXT, "TEXT"},
            {WHITESPACE_SPACE, "WHITESPACE_SPACE"}, {WHITESPACE_TAB, "WHITE_SPACE_TAB"}, {WHITESPACE_NEWLINE, "WHITESPACE_NEWLINE"},
            {COMMENT_SINGLE_LINE, "COMMENT_SINGLE_LINE"}, {COMMENT_MULTI_LINE, "COMMENT_MULTI_LINE"},
            {BACK_SLASH, "BACK_SLASH"}, {FORWARD_SLASH, "FORWARD_SLASH"},

            {PREPROCESSOR_INCLUDE, "PREPROCESSOR_INCLUDE"},
            {PREPROCESSOR_MACRO, "PREPROCESSOR_MACRO"}, {PREPROCESSOR_MACRET, "PREPROCESSOR_MACRET"},
            {PREPROCESSOR_MACEND, "PREPROCESSOR_MACEND"}, {PREPROCESSOR_INVOKE, "PREPROCESSOR_INVOKE"},
            {PREPROCESSOR_DEFINE, "PREPROCESSOR_DEFINE"}, {PREPROCESSOR_UNDEF, "PREPROCESSOR_UNDEF"},
            {PREPROCESSOR_IFDEF, "PREPROCESSOR_IFDEF"}, {PREPROCESSOR_IFNDEF, "PREPROCESSOR_IFNDEF"},
            {PREPROCESSOR_IFEQU, "PREPROCESSOR_IFEQU"}, {PREPROCESSOR_IFNEQU, "PREPROCESSOR_IFNEQU"},
            {PREPROCESSOR_IFLESS, "PREPROCESSOR_IFLESS"}, {PREPROCESSOR_IFMORE, "PREPROCESSOR_IFMORE"},
            {PREPROCESSOR_ELSE, "PREPROCESSOR_ELSE"}, {PREPROCESSOR_ELSEDEF, "PREPROCESSOR_ELSEDEF"},
            {PREPROCESSOR_ELSEEQU, "PREPROCESSOR_ELSEEQU"}, {PREPROCESSOR_ELSENEQU, "PREPROCESSOR_ELSENEQU"},
            {PREPROCESSOR_ELSELESS, "PREPROCESSOR_ELSELESS"}, {PREPROCESSOR_ELSEMORE, "PREPROCESSOR_ELSEMORE"},
            {PREPROCESSOR_ELSENDEF, "PREPROCESSOR_ELSENDEF"},
            {PREPROCESSOR_ENDIF, "PREPROCESSOR_ENDIF"},

            {VARIABLE_TYPE_BYTE, "VARIABLE_TYPE_BYTE"}, {VARIABLE_TYPE_DBYTE, "VARIABLE_TYPE_DBYTE"},
            {VARIABLE_TYPE_WORD, "VARIABLE_TYPE_WORD"}, {VARIABLE_TYPE_DWORD, "VARIABLE_TYPE_DWORD"},
            {VARIABLE_TYPE_CHAR, "VARIABLE_TYPE_CHAR"}, {VARIABLE_TYPE_STRING, "VARIABLE_TYPE_STRING"},
            {VARIABLE_TYPE_FLOAT, "VARIABLE_TYPE_FLOAT"}, {VARIABLE_TYPE_DOUBLE, "VARIABLE_TYPE_DOUBLE"},
            {VARIABLE_TYPE_BOOLEAN, "VARIABLE_TYPE_BOOLEAN"},

            {ASSEMBLER_GLOBAL, "ASSEMBLER_GLOBAL"},
            {ASSEMBLER_EXTERN, "ASSEMBLER_EXTERN"},
            {ASSEMBLER_EQU, "ASSEMBLER_EQU"},
            {ASSEMBLER_ORG, "ASSEMBLER_ORG"},
            {ASSEMBLER_SCOPE, "ASSEMBLER_SCOPE"},
            {ASSEMBLER_SCEND, "ASSEMBLER_SCEND"},
            {ASSEMBLER_DB_LOW_ENDIAN, "ASSEMBLER_DB_LOW_ENDIAN"},
            {ASSEMBLER_DDB_LOW_ENDIAN, "ASSEMBLER_DDB_LOW_ENDIAN"},
            {ASSEMBLER_DDB_HIGH_ENDIAN, "ASSEMBLER_DDB_HIGH_ENDIAN"},
            {ASSEMBLER_DW_LOW_ENDIAN, "ASSEMBLER_DW_LOW_ENDIAN"},
            {ASSEMBLER_DW_HIGH_ENDIAN, "ASSEMBLER_DW_HIGH_ENDIAN"},
            {ASSEMBLER_DDW_LOW_ENDIAN, "ASSEMBLER_DDW_LOW_ENDIAN"},
            {ASSEMBLER_DDW_HIGH_ENDIAN, "ASSEMBLER_DDW_HIGH_ENDIAN"},
            {ASSEMBLER_ASCII, "ASSEMBLER_ASCII"},
            {ASSEMBLER_ASCIZ, "ASSEMBLER_ASCIZ"},
            {ASSEMBLER_ADVANCE, "ASSEMBLER_ADVANCE"},
            {ASSEMBLER_FILL, "ASSEMBLER_FILL"},
            {ASSEMBLER_SPACE, "ASSEMBLER_SPACE"},
            {ASSEMBLER_CHECKPC, "ASSEMBLER_CHECKPC"},
            {ASSEMBLER_ALIGN, "ASSEMBLER_ALIGN"},
            {ASSEMBLER_BSS, "ASSEMBLER_BSS"},
            {ASSEMBLER_BSS_ABSOLUTE, "ASSEMBLER_BSS_ABSOLUTE"},
            {ASSEMBLER_DATA, "ASSEMBLER_DATA"},
            {ASSEMBLER_DATA_ABSOLUTE, "ASSEMBLER_DATA_ABSOLUTE"},
            {ASSEMBLER_TEXT, "ASSEMBLER_TEXT"},
            {ASSEMBLER_TEXT_ABSOLUTE, "ASSEMBLER_TEXT_ABSOLUTE"},
            {ASSEMBLER_STOP, "ASSEMBLER_STOP"},

			{INSTRUCTION_ADD, "INSTRUCTION_ADD"}, {INSTRUCTION_SUB,"INSTRUCTION_SUB"}, {INSTRUCTION_RSB, "INSTRUCTION_RSB"},
			{INSTRUCTION_ADC, "INSTRUCTION_ADC"}, {INSTRUCTION_SBC, "INSTRUCTION_SBC"}, {INSTRUCTION_RSC, "INSTRUCTION_RSC"},
			{INSTRUCTION_MUL, "INSTRUCTION_MUL"}, {INSTRUCTION_UMULL, "INSTRUCTION_UMULL"}, {INSTRUCTION_SMULL, "INSTRUCTION_SMULL"},
			{INSTRUCTION_VABS_F32, "INSTRUCTION_VABS_F32"}, {INSTRUCTION_VNEG_F32, "INSTRUCTION_VNEG_F32"}, {INSTRUCTION_VSQRT_F32, "INSTRUCTION_VSQRT_F32"},
			{INSTRUCTION_VADD_F32, "INSTRUCTION_VADD_F32"}, {INSTRUCTION_VSUB_F32, "INSTRUCTION_VSUB_F32"}, {INSTRUCTION_VDIV_F32, "INSTRUCTION_VDIV_F32"},
			{INSTRUCTION_VMUL_F32, "INSTRUCTION_VMUL_F32"}, {INSTRUCTION_VCMP_F32, "INSTRUCTION_VCMP_F32"}, {INSTRUCTION_VSEL_F32, "INSTRUCTION_VSEL_F32"},
			{INSTRUCTION_VCINT_U32_F32, "INSTRUCTION_VCINT_U32_F32"}, {INSTRUCTION_VCINT_S32_F32, "INSTRUCTION_VCINT_S32_F32"},
			{INSTRUCTION_VCFLO_U32_F32, "INSTRUCTION_VCFLO_U32_F32"}, {INSTRUCTION_VCFLO_S32_F32, "INSTRUCTION_VCFLO_S32_F32"},
			{INSTRUCTION_VMOV_F32, "INSTRUCTION_VMOV_F32"},
			{INSTRUCTION_AND, "INSTRUCTION_AND"}, {INSTRUCTION_ORR, "INSTRUCTION_ORR"}, {INSTRUCTION_EOR, "INSTRUCTION_EOR"}, {INSTRUCTION_BIC, "INSTRUCTION_BIC"},
			{INSTRUCTION_LSL, "INSTRUCTION_LSL"}, {INSTRUCTION_LSR, "INSTRUCTION_LSR"}, {INSTRUCTION_ASR, "INSTRUCTION_ASR"}, {INSTRUCTION_ROR, "INSTRUCTION_ROR"},
			{INSTRUCTION_CMP, "INSTRUCTION_CMP"}, {INSTRUCTION_CMN, "INSTRUCTION_CMN"}, {INSTRUCTION_TST, "INSTRUCTION_TST"}, {INSTRUCTION_TEQ, "INSTRUCTION_TEQ"},
			{INSTRUCTION_MOV, "INSTRUCTION_MOV"}, {INSTRUCTION_MVN, "INSTRUCTION_MVN"},
			{INSTRUCTION_LDR, "INSTRUCTION_LDR"}, {INSTRUCTION_STR, "INSTRUCTION_STR"}, {INSTRUCTION_SWP, "INSTRUCTION_SWP"},
			{INSTRUCTION_LDRB, "INSTRUCTION_LDRB"}, {INSTRUCTION_STRB, "INSTRUCTION_STRB"}, {INSTRUCTION_SWPB, "INSTRUCTION_SWPB"},
			{INSTRUCTION_LDRH, "INSTRUCTION_LDRH"}, {INSTRUCTION_STRH, "INSTRUCTION_STRH"}, {INSTRUCTION_SWPH, "INSTRUCTION_SWPH"},
			{INSTRUCTION_B, "INSTRUCTION_B"}, {INSTRUCTION_BL, "INSTRUCTION_B"}, {INSTRUCTION_BX, "INSTRUCTION_BX"}, {INSTRUCTION_BLX, "INSTRUCTION_BLX"}, {INSTRUCTION_SWI, "INSTRUCTION_SWI"},

			{CONDITION_EQ, "CONDITION_EQ"}, {CONDITION_NE, "CONDITION_NE"},
			{CONDITION_CS, "CONDITION_CS"}, {CONDITION_HS, "CONDITION_HS"},
			{CONDITION_CC, "CONDITION_CC"}, {CONDITION_LO, "CONDITION_LO"},
			{CONDITION_MI, "CONDITION_MI"}, {CONDITION_PL, "CONDITION_PL"},
			{CONDITION_VS, "CONDITION_VS"}, {CONDITION_VC, "CONDITION_VC"},
			{CONDITION_HI, "CONDITION_HI"}, {CONDITION_LS, "CONDITION_LS"},
			{CONDITION_GE, "CONDITION_GE"}, {CONDITION_LT, "CONDITION_LT"}, {CONDITION_GT, "CONDITION_GT"}, {CONDITION_LE, "CONDITION_LE"},
			{CONDITION_AL, "CONDITION_AL"}, {CONDITION_NV, "CONDITION_NV"},

            {NUMBER_SIGN, "NUMBER_SIGN"},
			{LITERAL_FLOAT_32, "LITERAL_FLOAT_32"},
            {LITERAL_NUMBER_BINARY, "LITERAL_NUMBER_BINARY"}, {LITERAL_NUMBER_OCTAL, "LITERAL_NUMBER_OCTAL"},
            {LITERAL_NUMBER_DECIMAL, "LITERAL_NUMBER_DECIMAL"}, {LITERAL_NUMBER_HEXADECIMAL, "LITERAL_NUMBER_HEXADECIMAL"},
            {LITERAL_CHAR, "LITERAL_CHAR"}, {LITERAL_STRING, "LITERAL_STRING"},
            {SYMBOL, "SYMBOL"},
            {COLON, "COLON"}, {COMMA, "COMMA"}, {PERIOD, "PERIOD"}, {SEMICOLON, "SEMICOLON"},
            {OPEN_PARANTHESIS, "OPEN_PARANTHESIS"}, {CLOSE_PARANTHESIS, "CLOSE_PARANTHESIS"},
            {OPEN_BRACKET, "OPEN_BRACKET"}, {CLOSE_BRACKET, "CLOSE_BRACKET"},
            {OPEN_BRACE, "OPEN_BRACE"}, {CLOSE_BRACE, "CLOSE_BRACE"},

            {OPERATOR_ADDITION, "OPERATOR_ADDITION"}, {OPERATOR_SUBTRACTION, "OPERATOR_SUBTRACTION"},
            {OPERATOR_MULTIPLICATION, "OPERATOR_MULTIPLICATION"}, {OPERATOR_DIVISION, "OPERATOR_DIVISION"},
            {OPERATOR_MODULUS, "OPERATOR_MODULUS"}, {OPERATOR_BITWISE_LEFT_SHIFT, "OPERATOR_BITWISE_LEFT_SHIFT"},
            {OPERATOR_BITWISE_RIGHT_SHIFT, "OPERATOR_BITWISE_RIGHT_SHIFT"}, {OPERATOR_BITWISE_XOR, "OPERATOR_BITWISE_XOR"},
            {OPERATOR_BITWISE_AND, "OPERATOR_BITWISE_AND"}, {OPERATOR_BITWISE_OR, "OPERATOR_BITWISE_OR"},
            {OPERATOR_BITWISE_COMPLEMENT, "OPERATOR_BITWISE_COMPLEMENT"}, {OPERATOR_LOGICAL_NOT, "OPERATOR_LOGICAL_NOT"},
            {OPERATOR_LOGICAL_EQUAL, "OPERATOR_LOGICAL_EQUAL"}, {OPERATOR_LOGICAL_NOT_EQUAL, "OPERATOR_LOGICAL_NOT_EQUAL"},
            {OPERATOR_LOGICAL_LESS_THAN, "OPERATOR_LOGICAL_LESS_THAN"}, {OPERATOR_LOGICAL_GREATER_THAN, "OPERATOR_LOGICAL_GREATER_THAN"},
            {OPERATOR_LOGICAL_LESS_THAN_OR_EQUAL, "OPERATOR_LOGICAL_LESS_THAN_OR_EQUAL"}, {OPERATOR_LOGICAL_GREATER_THAN_OR_EQUAL, "OPERATOR_LOGICAL_GREATER_THAN_OR_EQUAL"},
            {OPERATOR_LOGICAL_OR, "OPERATOR_LOGICAL_OR"}, {OPERATOR_LOGICAL_AND, "OPERATOR_LOGICAL_AND"},
        };

		inline static const std::unordered_map<Type,std::string> VARIABLE_TYPE_TO_NAME_MAP = {
			{VARIABLE_TYPE_BYTE, "BYTE"}, {VARIABLE_TYPE_DBYTE, "DBYTE"},
            {VARIABLE_TYPE_WORD, "WORD"}, {VARIABLE_TYPE_DWORD, "DWORD"},
            {VARIABLE_TYPE_CHAR, "CHAR"}, {VARIABLE_TYPE_STRING, "STRING"},
            {VARIABLE_TYPE_FLOAT, "FLOAT"}, {VARIABLE_TYPE_DOUBLE, "DOUBLE"},
            {VARIABLE_TYPE_BOOLEAN, "BOOLEAN"},
		};

        inline static const std::set<Type> WHITESPACES = {
            WHITESPACE_SPACE, WHITESPACE_TAB, WHITESPACE_NEWLINE
        };

        inline static const std::set<Type> COMMENTS = {
            COMMENT_SINGLE_LINE, COMMENT_MULTI_LINE
        };

        inline static const std::set<Type> PREPROCESSOR_DIRECTIVES = {
            PREPROCESSOR_INCLUDE, PREPROCESSOR_MACRO, PREPROCESSOR_MACRET, PREPROCESSOR_MACEND, PREPROCESSOR_INVOKE,
            PREPROCESSOR_DEFINE, PREPROCESSOR_UNDEF, PREPROCESSOR_IFDEF, PREPROCESSOR_IFNDEF, PREPROCESSOR_IFEQU,
            PREPROCESSOR_IFNEQU, PREPROCESSOR_IFLESS, PREPROCESSOR_IFMORE, PREPROCESSOR_ELSE,
            PREPROCESSOR_ELSEDEF, PREPROCESSOR_ELSENDEF,
            PREPROCESSOR_ELSEEQU, PREPROCESSOR_ELSENEQU, PREPROCESSOR_ELSELESS, PREPROCESSOR_ELSEMORE,
            PREPROCESSOR_ENDIF
        };

        inline static const std::set<Type> VARIABLE_TYPES = {
            VARIABLE_TYPE_BYTE, VARIABLE_TYPE_DBYTE, VARIABLE_TYPE_WORD, VARIABLE_TYPE_DWORD,
            VARIABLE_TYPE_CHAR, VARIABLE_TYPE_STRING, VARIABLE_TYPE_FLOAT, VARIABLE_TYPE_DOUBLE,
            VARIABLE_TYPE_BOOLEAN
        };

        inline static const std::set<Type> ASSEMBLER_DIRECTIVES = {
            ASSEMBLER_GLOBAL, ASSEMBLER_EXTERN,
            ASSEMBLER_EQU,
            ASSEMBLER_ORG,
            ASSEMBLER_SCOPE, ASSEMBLER_SCEND,
            ASSEMBLER_DB_LOW_ENDIAN,
            ASSEMBLER_DDB_LOW_ENDIAN, ASSEMBLER_DDB_HIGH_ENDIAN,
            ASSEMBLER_DW_LOW_ENDIAN, ASSEMBLER_DW_HIGH_ENDIAN,
            ASSEMBLER_DDW_LOW_ENDIAN, ASSEMBLER_DDW_HIGH_ENDIAN,
            ASSEMBLER_ASCII, ASSEMBLER_ASCIZ,
            ASSEMBLER_ADVANCE, ASSEMBLER_FILL, ASSEMBLER_SPACE,
            ASSEMBLER_CHECKPC,
            ASSEMBLER_ALIGN,
            ASSEMBLER_BSS, ASSEMBLER_BSS_ABSOLUTE,
            ASSEMBLER_DATA, ASSEMBLER_DATA_ABSOLUTE,
            ASSEMBLER_TEXT, ASSEMBLER_TEXT_ABSOLUTE,
            ASSEMBLER_STOP,
        };

		inline static const std::set<Type> INSTRUCTIONS = {
			INSTRUCTION_ADD, INSTRUCTION_SUB, INSTRUCTION_RSB,
			INSTRUCTION_ADC, INSTRUCTION_SBC, INSTRUCTION_RSC,
			INSTRUCTION_MUL, INSTRUCTION_UMULL, INSTRUCTION_SMULL,
			INSTRUCTION_VABS_F32, INSTRUCTION_VNEG_F32, INSTRUCTION_VSQRT_F32,
			INSTRUCTION_VADD_F32, INSTRUCTION_VSUB_F32, INSTRUCTION_VDIV_F32,
			INSTRUCTION_VMUL_F32, INSTRUCTION_VCMP_F32, INSTRUCTION_VSEL_F32,
			INSTRUCTION_VCINT_U32_F32, INSTRUCTION_VCINT_S32_F32,
			INSTRUCTION_VCFLO_U32_F32, INSTRUCTION_VCFLO_S32_F32,
			INSTRUCTION_VMOV_F32,
			INSTRUCTION_AND, INSTRUCTION_ORR, INSTRUCTION_EOR, INSTRUCTION_BIC,
			INSTRUCTION_LSL, INSTRUCTION_LSR, INSTRUCTION_ASR, INSTRUCTION_ROR,
			INSTRUCTION_CMP, INSTRUCTION_CMN, INSTRUCTION_TST, INSTRUCTION_TEQ,
			INSTRUCTION_MOV, INSTRUCTION_MVN,
			INSTRUCTION_LDR, INSTRUCTION_STR, INSTRUCTION_SWP,
			INSTRUCTION_LDRB, INSTRUCTION_STRB, INSTRUCTION_SWPB,
			INSTRUCTION_LDRH, INSTRUCTION_STRH, INSTRUCTION_SWPH,
			INSTRUCTION_B, INSTRUCTION_BL, INSTRUCTION_BX, INSTRUCTION_BLX, INSTRUCTION_SWI,
		};

		inline static const std::set<Type> CONDITIONS = {
			CONDITION_EQ, CONDITION_NE,
			CONDITION_CS, CONDITION_HS,
			CONDITION_CC, CONDITION_LO,
			CONDITION_MI, CONDITION_PL,
			CONDITION_VS, CONDITION_VC,
			CONDITION_HI, CONDITION_LS,
			CONDITION_GE, CONDITION_LT, CONDITION_GT, CONDITION_LE,
			CONDITION_AL, CONDITION_NV,
		};

        inline static const std::set<Type> LITERAL_NUMBERS = {
			LITERAL_FLOAT_32,
			LITERAL_NUMBER_BINARY, LITERAL_NUMBER_OCTAL, LITERAL_NUMBER_DECIMAL, LITERAL_NUMBER_HEXADECIMAL
        };

        inline static const std::set<Type> LITERAL_VALUES = {
			LITERAL_FLOAT_32,
			LITERAL_NUMBER_BINARY, LITERAL_NUMBER_OCTAL, LITERAL_NUMBER_DECIMAL, LITERAL_NUMBER_HEXADECIMAL,
            LITERAL_CHAR, LITERAL_STRING
        };

        inline static const std::set<Type> OPERATORS = {
            OPERATOR_ADDITION, OPERATOR_SUBTRACTION, OPERATOR_MULTIPLICATION, OPERATOR_DIVISION, OPERATOR_MODULUS,
            OPERATOR_BITWISE_LEFT_SHIFT, OPERATOR_BITWISE_RIGHT_SHIFT, OPERATOR_BITWISE_XOR, OPERATOR_BITWISE_AND,
            OPERATOR_BITWISE_OR, OPERATOR_BITWISE_COMPLEMENT, OPERATOR_LOGICAL_NOT, OPERATOR_LOGICAL_EQUAL,
            OPERATOR_LOGICAL_NOT_EQUAL, OPERATOR_LOGICAL_LESS_THAN, OPERATOR_LOGICAL_GREATER_THAN,
            OPERATOR_LOGICAL_LESS_THAN_OR_EQUAL, OPERATOR_LOGICAL_GREATER_THAN_OR_EQUAL, OPERATOR_LOGICAL_OR,
            OPERATOR_LOGICAL_AND
        };

        inline static const std::vector<std::pair<std::string, Type>> TOKEN_SPEC = {
			{"^ ", WHITESPACE_SPACE}, {"^\\t", WHITESPACE_TAB}, {"^\\n", WHITESPACE_NEWLINE},
			{"^[\\s^[ \\n\\t]]+", WHITESPACE},
            {"^;\\*[^*]*\\*+(?:[^;*][^*]*\\*+)*;", COMMENT_MULTI_LINE}, {"^;.*", COMMENT_SINGLE_LINE},
            {"^\\\\", BACK_SLASH}, {"^/", FORWARD_SLASH},
			{"^\\{", OPEN_BRACE}, {"^\\}", CLOSE_BRACE},
			{"^\\[", OPEN_BRACKET}, 	{"^\\]", CLOSE_BRACKET},
			{"^\\(", OPEN_PARANTHESIS},{"^\\)", CLOSE_PARANTHESIS},

			{"^#include\\b", PREPROCESSOR_INCLUDE},
			{"^#macro\\b", PREPROCESSOR_MACRO},
			{"^#macret\\b", PREPROCESSOR_MACRET},
			{"^#macend\\b", PREPROCESSOR_MACEND},
			{"^#invoke\\b", PREPROCESSOR_INVOKE},
			{"^#define\\b", PREPROCESSOR_DEFINE},
			{"^#undef\\b", PREPROCESSOR_UNDEF},
			{"^#ifdef\\b", PREPROCESSOR_IFDEF},
			{"^#ifndef\\b", PREPROCESSOR_IFNDEF},
            {"^#ifequ\\b", PREPROCESSOR_IFEQU},
            {"^#ifnequ\\b", PREPROCESSOR_IFNEQU},
            {"^#ifless\\b", PREPROCESSOR_IFLESS},
            {"^#ifmore\\b", PREPROCESSOR_IFMORE},
			{"^#else\\b", PREPROCESSOR_ELSE},
			{"^#elsedef\\b", PREPROCESSOR_ELSEDEF},
			{"^#elsendef\\b", PREPROCESSOR_ELSENDEF},
            {"^#elseequ\\b", PREPROCESSOR_ELSEEQU},
            {"^#elsenequ\\b", PREPROCESSOR_ELSENEQU},
            {"^#elseless\\b", PREPROCESSOR_ELSELESS},
            {"^#elsemore\\b", PREPROCESSOR_ELSEMORE},
			{"^#endif\\b", PREPROCESSOR_ENDIF},

            {"^BYTE(?=[\\s,\\)])", VARIABLE_TYPE_BYTE}, {"^DBYTE(?=[\\s,\\)])", VARIABLE_TYPE_DBYTE},
            {"^WORD(?=[\\s,\\)])", VARIABLE_TYPE_WORD}, {"^DWORD(?=[\\s,\\)])", VARIABLE_TYPE_DWORD},
            {"^CHAR(?=[\\s,\\)])", VARIABLE_TYPE_CHAR}, {"^STRING(?=[\\s,\\)])", VARIABLE_TYPE_STRING},
            {"^FLOAT(?=[\\s,\\)])", VARIABLE_TYPE_FLOAT}, {"^DOUBLE(?=[\\s,\\)])", VARIABLE_TYPE_DOUBLE},
            {"^BOOLEAN(?=[\\s,\\)])", VARIABLE_TYPE_BOOLEAN},

            {"^\\.global\\b", ASSEMBLER_GLOBAL},
            {"^\\.extern\\b", ASSEMBLER_EXTERN},
            {"^\\.equ\\b", ASSEMBLER_EQU},
            {"^\\.org\\b", ASSEMBLER_ORG},
            {"^\\.scope\\b", ASSEMBLER_SCOPE},
            {"^\\.scend\\b", ASSEMBLER_SCEND},
            {"^\\.db\\b", ASSEMBLER_DB_LOW_ENDIAN},
            {"^\\.ddb\\b", ASSEMBLER_DDB_LOW_ENDIAN},
            {"^\\.ddb\\*\\b", ASSEMBLER_DDB_HIGH_ENDIAN},
            {"^\\.dw\\b", ASSEMBLER_DW_LOW_ENDIAN},
            {"^\\.dw\\*\\b", ASSEMBLER_DW_HIGH_ENDIAN},
            {"^\\.ddw\\b", ASSEMBLER_DDW_LOW_ENDIAN},
            {"^\\.ddw\\*\\b", ASSEMBLER_DDW_HIGH_ENDIAN},
            {"^\\.ascii\\b", ASSEMBLER_ASCII},
            {"^\\.asciz\\b", ASSEMBLER_ASCIZ},
            {"^\\.advance\\b", ASSEMBLER_ADVANCE},
            {"^\\.fill\\b", ASSEMBLER_FILL},
            {"^\\.space\\b", ASSEMBLER_SPACE},
            {"^\\.checkpc\\b", ASSEMBLER_CHECKPC},
            {"^\\.align\\b", ASSEMBLER_ALIGN},
            {"^\\.bss\\b", ASSEMBLER_BSS},
            {"^\\.bss\\*\\b", ASSEMBLER_BSS_ABSOLUTE},
            {"^\\.data\\b", ASSEMBLER_DATA},
            {"^\\.data\\*\\b", ASSEMBLER_DATA_ABSOLUTE},
            {"^\\.text\\b", ASSEMBLER_TEXT},
            {"^\\.text\\*\\b", ASSEMBLER_TEXT_ABSOLUTE},
            {"^\\.stop\\b", ASSEMBLER_STOP},

			{"^add[s]?\\b", INSTRUCTION_ADD},
			{"^sub[s]?\\b", INSTRUCTION_SUB},
			{"^rsb[s]?\\b", INSTRUCTION_RSB},
			{"^adc[s]?\\b", INSTRUCTION_ADC},
			{"^sbc[s]?\\b", INSTRUCTION_SBC},
			{"^rsc[s]?\\b", INSTRUCTION_RSC},
			{"^mul[s]?\\b", INSTRUCTION_MUL},
			{"^umull[s]?\\b", INSTRUCTION_UMULL},
			{"^smull[s]?\\b", INSTRUCTION_SMULL},
			{"^vabs\\.f32\\b", INSTRUCTION_VABS_F32},
			{"^vneg\\.f32\\b", INSTRUCTION_VNEG_F32},
			{"^vsqrt\\.f32\\b", INSTRUCTION_VSQRT_F32},
			{"^vadd\\.f32\\b", INSTRUCTION_VADD_F32},
			{"^vsub\\.f32\\b", INSTRUCTION_VSUB_F32},
			{"^vdiv\\.f32\\b", INSTRUCTION_VDIV_F32},
			{"^vmul\\.f32\\b", INSTRUCTION_VMUL_F32},
			{"^vcmp\\.f32\\b", INSTRUCTION_VCMP_F32},
			{"^vsel\\.f32\\b", INSTRUCTION_VSEL_F32},
			{"^vcint\\.u32\\.f32\\b", INSTRUCTION_VCINT_U32_F32},
			{"^vcint\\.s32\\.f32\\b", INSTRUCTION_VCINT_S32_F32},
			{"^vcflo\\.u32\\.f32\\b", INSTRUCTION_VCFLO_U32_F32},
			{"^vcflo\\.s32\\.f32\\b", INSTRUCTION_VCFLO_S32_F32},
			{"^vmov\\.f32\\b", INSTRUCTION_VMOV_F32},
			{"^and[s]?\\b", INSTRUCTION_AND},
			{"^orr[s]?\\b", INSTRUCTION_ORR},
			{"^eor[s]?\\b", INSTRUCTION_EOR},
			{"^bic[s]?\\b", INSTRUCTION_BIC},
			{"^lsl[s]?\\b", INSTRUCTION_LSL},
			{"^lsr[s]?\\b", INSTRUCTION_LSR},
			{"^asr[s]?\\b", INSTRUCTION_ASR},
			{"^ror[s]?\\b", INSTRUCTION_ROR},
			{"^cmp\\b", INSTRUCTION_CMP},
			{"^cmn\\b", INSTRUCTION_CMN},
			{"^tst\\b", INSTRUCTION_TST},
			{"^teq\\b", INSTRUCTION_TEQ},
			{"^mov[s]?\\b", INSTRUCTION_MOV},
			{"^mvn[s]?\\b", INSTRUCTION_MVN},
			{"^ldr[s]?\\b", INSTRUCTION_LDR},
			{"^str[s]?\\b", INSTRUCTION_STR},
			{"^swp[s]?\\b", INSTRUCTION_SWP},
			{"^ldr[s]b?\\b", INSTRUCTION_LDRB},
			{"^str[s]b?\\b", INSTRUCTION_STRB},
			{"^swp[s]b?\\b", INSTRUCTION_SWPB},
			{"^ldr[s]h?\\b", INSTRUCTION_LDRH},
			{"^str[s]h?\\b", INSTRUCTION_STRH},
			{"^swp[s]h?\\b", INSTRUCTION_SWPH},
			{"^b\\b", INSTRUCTION_B},
			{"^bl\\b", INSTRUCTION_BL},
			{"^bx\\b", INSTRUCTION_BX},
			{"^blx\\b", INSTRUCTION_BLX},
			{"^swi\\b", INSTRUCTION_SWI},

			{"^eq\\b", CONDITION_EQ}, {"^ne\\b", CONDITION_NE},
			{"^cs\\b", CONDITION_CS}, {"^hs\\b", CONDITION_HS},
			{"^cc\\b", CONDITION_CC}, {"^lo\\b", CONDITION_LO},
			{"^mi\\b", CONDITION_MI}, {"^pl\\b", CONDITION_PL},
			{"^vs\\b", CONDITION_VS}, {"^vc\\b", CONDITION_VC},
			{"^hi\\b", CONDITION_HI}, {"^ls\\b", CONDITION_LS},
			{"^ge\\b", CONDITION_GE}, {"^lt\\b", CONDITION_LT}, {"^gt\\b", CONDITION_GT}, {"^le\\b", CONDITION_LE},
			{"^al\\b", CONDITION_AL}, {"^nv\\b", CONDITION_NV},

            {"^#", NUMBER_SIGN},
			{"^[0-9]*\\.[0-9]+", LITERAL_FLOAT_32},
            {"^%[0-1]+", LITERAL_NUMBER_BINARY},
            {"^@[0-7]+", LITERAL_NUMBER_OCTAL},
            {"^[0-9]+", LITERAL_NUMBER_DECIMAL},
            {"^\\$[0-9a-fA-F]+", LITERAL_NUMBER_HEXADECIMAL},

			{"^\'.\'", LITERAL_CHAR}, {"^\".*\"", LITERAL_STRING},
			{"^[a-zA-Z_][a-zA-Z0-9_]*", SYMBOL},

			{"^,", COMMA}, {"^:", COLON}, {"^\\.", PERIOD}, {"^;", SEMICOLON},

			{"^\\+", OPERATOR_ADDITION}, {"^\\-", OPERATOR_SUBTRACTION},
            {"^\\*", OPERATOR_MULTIPLICATION}, {"^\\/", OPERATOR_DIVISION},
            {"^\\%", OPERATOR_MODULUS},
            {"^\\|\\|", OPERATOR_LOGICAL_OR}, {"^\\&\\&", OPERATOR_LOGICAL_AND},
			{"^\\<\\<", OPERATOR_BITWISE_LEFT_SHIFT}, {"^\\>\\>", OPERATOR_BITWISE_RIGHT_SHIFT},
			{"^\\^", OPERATOR_BITWISE_XOR}, {"^\\&", OPERATOR_BITWISE_AND},
            {"^\\|", OPERATOR_BITWISE_OR}, {"^~", OPERATOR_BITWISE_COMPLEMENT},
            {"^==", OPERATOR_LOGICAL_EQUAL}, {"^!=", OPERATOR_LOGICAL_NOT_EQUAL},
			{"^!", OPERATOR_LOGICAL_NOT},
            {"^\\<=", OPERATOR_LOGICAL_LESS_THAN_OR_EQUAL}, {"^\\>=", OPERATOR_LOGICAL_GREATER_THAN_OR_EQUAL},
            {"^\\<", OPERATOR_LOGICAL_LESS_THAN}, {"^\\>", OPERATOR_LOGICAL_GREATER_THAN},
		};

        /**
		 * Base source code character set
		 *
		 * a-z A-Z 0-9 _ { } [ ] ( ) < > % : ; . , ? * + - / ^ & | ~ ! = " ' \ # @ $
		 */
		struct Token {

			Type type;
			std::string value;

			Token(Type type, std::string value) {
				this->type = type;
				this->value = value;
			}

			std::string to_string() {
				if (type == WHITESPACE_SPACE || type == WHITESPACE_TAB || type == WHITESPACE_NEWLINE) {
					std::string toString = TYPE_TO_NAME_MAP.at(type) + ":";
					for (auto i = 0; i < value.length(); i++) {
						toString += " " + std::to_string(value[i]);
					}
					return toString;
				} else if (type == COMMENT_SINGLE_LINE || type == COMMENT_MULTI_LINE) {
                    return TYPE_TO_NAME_MAP.at(type);
                }

				return TYPE_TO_NAME_MAP.at(type) + ": " + value;
			}
		};


        static std::vector<Token>& tokenize(File* srcFile);
		static std::vector<Token>& tokenize(std::string source_code);
};

#endif