#include "assembler/Tokenizer.h"
#include "util/Logger.h"

#include <regex>

/**
 * Converts the source file contents into a list of tokens
 *
 * @param srcFile The source file to tokenize
 * @return A list of tokens
 */
std::vector<Tokenizer::Token>& Tokenizer::tokenize(File srcFile) {
    lgr::log(lgr::Logger::LogType::DEBUG, std::stringstream() << "Tokenizer::tokenize() - Tokenizing file: " << srcFile.get_name());
	FileReader reader(srcFile);

    // append a new line to the end to allow regex matching to match an ending whitespace
	std::string source_code = reader.read_all() + "\n";
	reader.close();

	std::vector<Token>& tokens = tokenize(source_code);
	lgr::log(lgr::Logger::LogType::DEBUG, std::stringstream() << "Tokenizer::tokenize() - Tokenized file: " << srcFile.get_name());
	return tokens;
}

/**
 * Converts the source code into a list of tokens
 *
 * @param source_code The source code to tokenize
 * @return A list of tokens
 */
std::vector<Tokenizer::Token>& Tokenizer::tokenize(std::string source_code) {
	std::vector<Token>* tokens = new std::vector<Token>();
	while (source_code.size() > 0) {
		// try to match regex
		bool matched = false;
		for (std::pair<std::string, Type> regexPair : TOKEN_SPEC) {
			std::string regex = regexPair.first;
			Type type = regexPair.second;
			std::regex token_regex(regex);
			std::smatch match;
			if (std::regex_search(source_code, match, token_regex)) {
				// matched regex
				std::string token_value = match.str();
				tokens->push_back(Token(type, token_value));
				source_code = match.suffix();
				matched = true;

                // lgr::log(lgr::Logger::LogType::Log, std::stringstream() << "Tokenizer::tokenize() - Token " << tokens.size()-1 << ": " << tokens.back().toString());
				break;
			}
		}

		// check if regex matched
		lgr::EXPECT_TRUE(matched, lgr::Logger::LogType::ERROR, std::stringstream() << "Tokenizer::tokenize() - Could not match regex to source code: " << source_code);
	}

	// print out tokens
	for (int i = 0; i < tokens->size(); i++) {
		lgr::log(lgr::Logger::LogType::DEBUG, std::stringstream() << "Tokenizer::tokenize() - Token[" << i << "]=" << tokens->at(i).to_string());
	}

	return *tokens;
}

const std::unordered_map<Tokenizer::Type, std::string> Tokenizer::TYPE_TO_NAME_MAP = {
	{UNKNOWN, "UNKNOWN"},

	{LABEL, "LABEL"},
	{TEXT, "TEXT"},
	{WHITESPACE_SPACE, "WHITESPACE_SPACE"}, {WHITESPACE_TAB, "WHITE_SPACE_TAB"}, {WHITESPACE_NEWLINE, "WHITESPACE_NEWLINE"},
	{COMMENT_SINGLE_LINE, "COMMENT_SINGLE_LINE"}, {COMMENT_MULTI_LINE, "COMMENT_MULTI_LINE"},
	{BACK_SLASH, "BACK_SLASH"}, {FORWARD_SLASH, "FORWARD_SLASH"},

	{PREPROCESSOR_INCLUDE, "PREPROCESSOR_INCLUDE"},
	{PREPROCESSOR_MACRO, "PREPROCESSOR_MACRO"}, {PREPROCESSOR_MACRET, "PREPROCESSOR_MACRET"},
	{PREPROCESSOR_MACEND, "PREPROCESSOR_MACEND"}, {PREPROCESSOR_INVOKE, "PREPROCESSOR_INVOKE"},
	{PREPROCESSOR_DEFINE, "PREPROCESSOR_DEFINE"}, {PREPROCESSOR_UNDEF, "PREPROCESSOR_UNDEF"},
	{PREPROCESSOR_IFDEF, "PREPROCESSOR_IFDEF"}, {PREPROCESSOR_IFNDEF, "PREPROCESSOR_IFNDEF"},
	{PREPROCESSOR_IFEQU, "PREPROCESSOR_IFEQU"}, {PREPROCESSOR_IFNEQU, "PREPROCESSOR_IFNEQU"},
	{PREPROCESSOR_IFLESS, "PREPROCESSOR_IFLESS"}, {PREPROCESSOR_IFMORE, "PREPROCESSOR_IFMORE"},
	{PREPROCESSOR_ELSE, "PREPROCESSOR_ELSE"}, {PREPROCESSOR_ELSEDEF, "PREPROCESSOR_ELSEDEF"},
	{PREPROCESSOR_ELSEEQU, "PREPROCESSOR_ELSEEQU"}, {PREPROCESSOR_ELSENEQU, "PREPROCESSOR_ELSENEQU"},
	{PREPROCESSOR_ELSELESS, "PREPROCESSOR_ELSELESS"}, {PREPROCESSOR_ELSEMORE, "PREPROCESSOR_ELSEMORE"},
	{PREPROCESSOR_ELSENDEF, "PREPROCESSOR_ELSENDEF"},
	{PREPROCESSOR_ENDIF, "PREPROCESSOR_ENDIF"},

	{ASSEMBLER_GLOBAL, "ASSEMBLER_GLOBAL"},
	{ASSEMBLER_EXTERN, "ASSEMBLER_EXTERN"},
	{ASSEMBLER_ORG, "ASSEMBLER_ORG"},
	{ASSEMBLER_SCOPE, "ASSEMBLER_SCOPE"},
	{ASSEMBLER_SCEND, "ASSEMBLER_SCEND"},
	{ASSEMBLER_ASCII, "ASSEMBLER_ASCII"},
	{ASSEMBLER_ASCIZ, "ASSEMBLER_ASCIZ"},
	{ASSEMBLER_ADVANCE, "ASSEMBLER_ADVANCE"},
	{ASSEMBLER_FILL, "ASSEMBLER_FILL"},
	{ASSEMBLER_ALIGN, "ASSEMBLER_ALIGN"},
	{ASSEMBLER_SECTION, "ASSEMBLER_SECTION"},
	{ASSEMBLER_BSS, "ASSEMBLER_BSS"},
	{ASSEMBLER_DATA, "ASSEMBLER_DATA"},
	{ASSEMBLER_TEXT, "ASSEMBLER_TEXT"},
	{ASSEMBLER_STOP, "ASSEMBLER_STOP"},
	{ASSEMBLER_BYTE, "ASSEMBLER_BYTE"},
	{ASSEMBLER_DBYTE, "ASSEMBLER_DBYTE"},
	{ASSEMBLER_WORD, "ASSEMBLER_WORD"},
	{ASSEMBLER_DWORD, "ASSEMBLER_DWORD"},
	{ASSEMBLER_SBYTE, "ASSEMBLER_SBYTE"},
	{ASSEMBLER_SDBYTE, "ASSEMBLER_SDBYTE"},
	{ASSEMBLER_SWORD, "ASSEMBLER_SWORD"},
	{ASSEMBLER_SDWORD, "ASSEMBLER_SDWORD"},

	{RELOCATION_EMU32_O_LO12, "RELOCATION_EMU32_O_LO12"}, {RELOCATION_EMU32_ADRP_HI20, "RELOCATION_EMU32_ADRP_HI20"},
	{RELOCATION_EMU32_MOV_LO19, "RELOCATION_EMU32_MOV_LO19"}, {RELOCATION_EMU32_MOV_HI13, "RELOCATION_EMU32_MOV_HI13"},

	{REGISTER_X0, "REGISTER_X0"}, {REGISTER_X1, "REGISTER_X1"},
	{REGISTER_X2, "REGISTER_X2"}, {REGISTER_X3, "REGISTER_X3"},
	{REGISTER_X4, "REGISTER_X4"}, {REGISTER_X5, "REGISTER_X5"},
	{REGISTER_X6, "REGISTER_X6"}, {REGISTER_X7, "REGISTER_X7"},
	{REGISTER_X8, "REGISTER_X8"}, {REGISTER_X9, "REGISTER_X9"},
	{REGISTER_X10, "REGISTER_X10"}, {REGISTER_X11, "REGISTER_X11"},
	{REGISTER_X12, "REGISTER_X12"}, {REGISTER_X13, "REGISTER_X13"},
	{REGISTER_X14, "REGISTER_X14"}, {REGISTER_X15, "REGISTER_X15"},
	{REGISTER_X16, "REGISTER_X16"}, {REGISTER_X17, "REGISTER_X17"},
	{REGISTER_X18, "REGISTER_X18"}, {REGISTER_X19, "REGISTER_X19"},
	{REGISTER_X20, "REGISTER_X20"}, {REGISTER_X21, "REGISTER_X21"},
	{REGISTER_X22, "REGISTER_X22"}, {REGISTER_X23, "REGISTER_X23"},
	{REGISTER_X24, "REGISTER_X24"}, {REGISTER_X25, "REGISTER_X25"},
	{REGISTER_X26, "REGISTER_X26"}, {REGISTER_X27, "REGISTER_X27"},
	{REGISTER_X28, "REGISTER_X28"}, {REGISTER_X29, "REGISTER_X29"},
	{REGISTER_XZR, "REGISTER_XZR"}, {REGISTER_SP, "REGISTER_SP"},

	{INSTRUCTION_HLT, "INSTRUCTION_HLT"},
	{INSTRUCTION_ADD, "INSTRUCTION_ADD"}, {INSTRUCTION_SUB,"INSTRUCTION_SUB"}, {INSTRUCTION_RSB, "INSTRUCTION_RSB"},
	{INSTRUCTION_ADC, "INSTRUCTION_ADC"}, {INSTRUCTION_SBC, "INSTRUCTION_SBC"}, {INSTRUCTION_RSC, "INSTRUCTION_RSC"},
	{INSTRUCTION_MUL, "INSTRUCTION_MUL"}, {INSTRUCTION_UMULL, "INSTRUCTION_UMULL"}, {INSTRUCTION_SMULL, "INSTRUCTION_SMULL"},
	{INSTRUCTION_VABS_F32, "INSTRUCTION_VABS_F32"}, {INSTRUCTION_VNEG_F32, "INSTRUCTION_VNEG_F32"}, {INSTRUCTION_VSQRT_F32, "INSTRUCTION_VSQRT_F32"},
	{INSTRUCTION_VADD_F32, "INSTRUCTION_VADD_F32"}, {INSTRUCTION_VSUB_F32, "INSTRUCTION_VSUB_F32"}, {INSTRUCTION_VDIV_F32, "INSTRUCTION_VDIV_F32"},
	{INSTRUCTION_VMUL_F32, "INSTRUCTION_VMUL_F32"}, {INSTRUCTION_VCMP_F32, "INSTRUCTION_VCMP_F32"}, {INSTRUCTION_VSEL_F32, "INSTRUCTION_VSEL_F32"},
	{INSTRUCTION_VCINT_U32_F32, "INSTRUCTION_VCINT_U32_F32"}, {INSTRUCTION_VCINT_S32_F32, "INSTRUCTION_VCINT_S32_F32"},
	{INSTRUCTION_VCFLO_U32_F32, "INSTRUCTION_VCFLO_U32_F32"}, {INSTRUCTION_VCFLO_S32_F32, "INSTRUCTION_VCFLO_S32_F32"},
	{INSTRUCTION_VMOV_F32, "INSTRUCTION_VMOV_F32"},
	{INSTRUCTION_AND, "INSTRUCTION_AND"}, {INSTRUCTION_ORR, "INSTRUCTION_ORR"}, {INSTRUCTION_EOR, "INSTRUCTION_EOR"}, {INSTRUCTION_BIC, "INSTRUCTION_BIC"},
	{INSTRUCTION_LSL, "INSTRUCTION_LSL"}, {INSTRUCTION_LSR, "INSTRUCTION_LSR"}, {INSTRUCTION_ASR, "INSTRUCTION_ASR"}, {INSTRUCTION_ROR, "INSTRUCTION_ROR"},
	{INSTRUCTION_CMP, "INSTRUCTION_CMP"}, {INSTRUCTION_CMN, "INSTRUCTION_CMN"}, {INSTRUCTION_TST, "INSTRUCTION_TST"}, {INSTRUCTION_TEQ, "INSTRUCTION_TEQ"},
	{INSTRUCTION_MOV, "INSTRUCTION_MOV"}, {INSTRUCTION_MVN, "INSTRUCTION_MVN"},
	{INSTRUCTION_LDR, "INSTRUCTION_LDR"}, {INSTRUCTION_STR, "INSTRUCTION_STR"}, {INSTRUCTION_SWP, "INSTRUCTION_SWP"},
	{INSTRUCTION_LDRB, "INSTRUCTION_LDRB"}, {INSTRUCTION_STRB, "INSTRUCTION_STRB"}, {INSTRUCTION_SWPB, "INSTRUCTION_SWPB"},
	{INSTRUCTION_LDRH, "INSTRUCTION_LDRH"}, {INSTRUCTION_STRH, "INSTRUCTION_STRH"}, {INSTRUCTION_SWPH, "INSTRUCTION_SWPH"},
	{INSTRUCTION_B, "INSTRUCTION_B"}, {INSTRUCTION_BL, "INSTRUCTION_B"}, {INSTRUCTION_BX, "INSTRUCTION_BX"}, {INSTRUCTION_BLX, "INSTRUCTION_BLX"}, {INSTRUCTION_SWI, "INSTRUCTION_SWI"},
	{INSTRUCTION_ADRP, "INSTRUCTION_ADRP"},

	{INSTRUCTION_RET, "INSTRUCTION_RET"},

	{CONDITION_EQ, "CONDITION_EQ"}, {CONDITION_NE, "CONDITION_NE"},
	{CONDITION_CS, "CONDITION_CS"}, {CONDITION_HS, "CONDITION_HS"},
	{CONDITION_CC, "CONDITION_CC"}, {CONDITION_LO, "CONDITION_LO"},
	{CONDITION_MI, "CONDITION_MI"}, {CONDITION_PL, "CONDITION_PL"},
	{CONDITION_VS, "CONDITION_VS"}, {CONDITION_VC, "CONDITION_VC"},
	{CONDITION_HI, "CONDITION_HI"}, {CONDITION_LS, "CONDITION_LS"},
	{CONDITION_GE, "CONDITION_GE"}, {CONDITION_LT, "CONDITION_LT"}, {CONDITION_GT, "CONDITION_GT"}, {CONDITION_LE, "CONDITION_LE"},
	{CONDITION_AL, "CONDITION_AL"}, {CONDITION_NV, "CONDITION_NV"},

	{NUMBER_SIGN, "NUMBER_SIGN"},
	{LITERAL_FLOAT_32, "LITERAL_FLOAT_32"},
	{LITERAL_NUMBER_BINARY, "LITERAL_NUMBER_BINARY"}, {LITERAL_NUMBER_OCTAL, "LITERAL_NUMBER_OCTAL"},
	{LITERAL_NUMBER_DECIMAL, "LITERAL_NUMBER_DECIMAL"}, {LITERAL_NUMBER_HEXADECIMAL, "LITERAL_NUMBER_HEXADECIMAL"},
	{LITERAL_CHAR, "LITERAL_CHAR"}, {LITERAL_STRING, "LITERAL_STRING"},
	{SYMBOL, "SYMBOL"},
	{COLON, "COLON"}, {COMMA, "COMMA"}, {PERIOD, "PERIOD"}, {SEMICOLON, "SEMICOLON"},
	{OPEN_PARANTHESIS, "OPEN_PARANTHESIS"}, {CLOSE_PARANTHESIS, "CLOSE_PARANTHESIS"},
	{OPEN_BRACKET, "OPEN_BRACKET"}, {CLOSE_BRACKET, "CLOSE_BRACKET"},
	{OPEN_BRACE, "OPEN_BRACE"}, {CLOSE_BRACE, "CLOSE_BRACE"},

	{OPERATOR_ADDITION, "OPERATOR_ADDITION"}, {OPERATOR_SUBTRACTION, "OPERATOR_SUBTRACTION"},
	{OPERATOR_MULTIPLICATION, "OPERATOR_MULTIPLICATION"}, {OPERATOR_DIVISION, "OPERATOR_DIVISION"},
	{OPERATOR_MODULUS, "OPERATOR_MODULUS"}, {OPERATOR_BITWISE_LEFT_SHIFT, "OPERATOR_BITWISE_LEFT_SHIFT"},
	{OPERATOR_BITWISE_RIGHT_SHIFT, "OPERATOR_BITWISE_RIGHT_SHIFT"}, {OPERATOR_BITWISE_XOR, "OPERATOR_BITWISE_XOR"},
	{OPERATOR_BITWISE_AND, "OPERATOR_BITWISE_AND"}, {OPERATOR_BITWISE_OR, "OPERATOR_BITWISE_OR"},
	{OPERATOR_BITWISE_COMPLEMENT, "OPERATOR_BITWISE_COMPLEMENT"}, {OPERATOR_LOGICAL_NOT, "OPERATOR_LOGICAL_NOT"},
	{OPERATOR_LOGICAL_EQUAL, "OPERATOR_LOGICAL_EQUAL"}, {OPERATOR_LOGICAL_NOT_EQUAL, "OPERATOR_LOGICAL_NOT_EQUAL"},
	{OPERATOR_LOGICAL_LESS_THAN, "OPERATOR_LOGICAL_LESS_THAN"}, {OPERATOR_LOGICAL_GREATER_THAN, "OPERATOR_LOGICAL_GREATER_THAN"},
	{OPERATOR_LOGICAL_LESS_THAN_OR_EQUAL, "OPERATOR_LOGICAL_LESS_THAN_OR_EQUAL"}, {OPERATOR_LOGICAL_GREATER_THAN_OR_EQUAL, "OPERATOR_LOGICAL_GREATER_THAN_OR_EQUAL"},
	{OPERATOR_LOGICAL_OR, "OPERATOR_LOGICAL_OR"}, {OPERATOR_LOGICAL_AND, "OPERATOR_LOGICAL_AND"},
};

const std::set<Tokenizer::Type> Tokenizer::WHITESPACES = {
	WHITESPACE_SPACE, WHITESPACE_TAB, WHITESPACE_NEWLINE
};

const std::set<Tokenizer::Type> Tokenizer::COMMENTS = {
    COMMENT_SINGLE_LINE, COMMENT_MULTI_LINE
};

const std::set<Tokenizer::Type> Tokenizer::PREPROCESSOR_DIRECTIVES = {
	PREPROCESSOR_INCLUDE, PREPROCESSOR_MACRO, PREPROCESSOR_MACRET, PREPROCESSOR_MACEND, PREPROCESSOR_INVOKE,
	PREPROCESSOR_DEFINE, PREPROCESSOR_UNDEF, PREPROCESSOR_IFDEF, PREPROCESSOR_IFNDEF, PREPROCESSOR_IFEQU,
	PREPROCESSOR_IFNEQU, PREPROCESSOR_IFLESS, PREPROCESSOR_IFMORE, PREPROCESSOR_ELSE,
	PREPROCESSOR_ELSEDEF, PREPROCESSOR_ELSENDEF,
	PREPROCESSOR_ELSEEQU, PREPROCESSOR_ELSENEQU, PREPROCESSOR_ELSELESS, PREPROCESSOR_ELSEMORE,
	PREPROCESSOR_ENDIF
};

const std::set<Tokenizer::Type> Tokenizer::ASSEMBLER_DIRECTIVES = {
	ASSEMBLER_GLOBAL, ASSEMBLER_EXTERN,
	ASSEMBLER_ORG,
	ASSEMBLER_SCOPE, ASSEMBLER_SCEND,
	ASSEMBLER_ASCII, ASSEMBLER_ASCIZ,
	ASSEMBLER_ADVANCE, ASSEMBLER_FILL,
	ASSEMBLER_ALIGN,
	ASSEMBLER_SECTION,
	ASSEMBLER_BSS,
	ASSEMBLER_DATA,
	ASSEMBLER_TEXT,
	ASSEMBLER_STOP,
	ASSEMBLER_BYTE, ASSEMBLER_DBYTE, ASSEMBLER_WORD, ASSEMBLER_DWORD,
	ASSEMBLER_SBYTE, ASSEMBLER_SDBYTE, ASSEMBLER_SWORD, ASSEMBLER_SDWORD,
};

const std::set<Tokenizer::Type> Tokenizer::RELOCATIONS = {
	RELOCATION_EMU32_O_LO12, RELOCATION_EMU32_ADRP_HI20,
	RELOCATION_EMU32_MOV_LO19, RELOCATION_EMU32_MOV_HI13,
};

const std::set<Tokenizer::Type> Tokenizer::REGISTERS = {
	REGISTER_X0, REGISTER_X1,
	REGISTER_X2, REGISTER_X3,
	REGISTER_X4, REGISTER_X5,
	REGISTER_X6, REGISTER_X7,
	REGISTER_X8, REGISTER_X9,
	REGISTER_X10, REGISTER_X11,
	REGISTER_X12, REGISTER_X13,
	REGISTER_X14, REGISTER_X15,
	REGISTER_X16, REGISTER_X17,
	REGISTER_X18, REGISTER_X19,
	REGISTER_X20, REGISTER_X21,
	REGISTER_X22, REGISTER_X23,
	REGISTER_X24, REGISTER_X25,
	REGISTER_X26, REGISTER_X27,
	REGISTER_X28, REGISTER_X29,
	REGISTER_XZR, REGISTER_SP,
};

const std::set<Tokenizer::Type> Tokenizer::INSTRUCTIONS = {
	INSTRUCTION_HLT,
	INSTRUCTION_ADD, INSTRUCTION_SUB, INSTRUCTION_RSB,
	INSTRUCTION_ADC, INSTRUCTION_SBC, INSTRUCTION_RSC,
	INSTRUCTION_MUL, INSTRUCTION_UMULL, INSTRUCTION_SMULL,
	INSTRUCTION_VABS_F32, INSTRUCTION_VNEG_F32, INSTRUCTION_VSQRT_F32,
	INSTRUCTION_VADD_F32, INSTRUCTION_VSUB_F32, INSTRUCTION_VDIV_F32,
	INSTRUCTION_VMUL_F32, INSTRUCTION_VCMP_F32, INSTRUCTION_VSEL_F32,
	INSTRUCTION_VCINT_U32_F32, INSTRUCTION_VCINT_S32_F32,
	INSTRUCTION_VCFLO_U32_F32, INSTRUCTION_VCFLO_S32_F32,
	INSTRUCTION_VMOV_F32,
	INSTRUCTION_AND, INSTRUCTION_ORR, INSTRUCTION_EOR, INSTRUCTION_BIC,
	INSTRUCTION_LSL, INSTRUCTION_LSR, INSTRUCTION_ASR, INSTRUCTION_ROR,
	INSTRUCTION_CMP, INSTRUCTION_CMN, INSTRUCTION_TST, INSTRUCTION_TEQ,
	INSTRUCTION_MOV, INSTRUCTION_MVN,
	INSTRUCTION_LDR, INSTRUCTION_STR, INSTRUCTION_SWP,
	INSTRUCTION_LDRB, INSTRUCTION_STRB, INSTRUCTION_SWPB,
	INSTRUCTION_LDRH, INSTRUCTION_STRH, INSTRUCTION_SWPH,
	INSTRUCTION_B, INSTRUCTION_BL, INSTRUCTION_BX, INSTRUCTION_BLX, INSTRUCTION_SWI,
	INSTRUCTION_ADRP,

	INSTRUCTION_RET,
};

const std::set<Tokenizer::Type> Tokenizer::CONDITIONS = {
	CONDITION_EQ, CONDITION_NE,
	CONDITION_CS, CONDITION_HS,
	CONDITION_CC, CONDITION_LO,
	CONDITION_MI, CONDITION_PL,
	CONDITION_VS, CONDITION_VC,
	CONDITION_HI, CONDITION_LS,
	CONDITION_GE, CONDITION_LT, CONDITION_GT, CONDITION_LE,
	CONDITION_AL, CONDITION_NV,
};

const std::set<Tokenizer::Type> Tokenizer::LITERAL_NUMBERS = {
	LITERAL_FLOAT_32,
	LITERAL_NUMBER_BINARY, LITERAL_NUMBER_OCTAL, LITERAL_NUMBER_DECIMAL, LITERAL_NUMBER_HEXADECIMAL
};

const std::set<Tokenizer::Type> Tokenizer::LITERAL_VALUES = {
	LITERAL_FLOAT_32,
	LITERAL_NUMBER_BINARY, LITERAL_NUMBER_OCTAL, LITERAL_NUMBER_DECIMAL, LITERAL_NUMBER_HEXADECIMAL,
	LITERAL_CHAR, LITERAL_STRING
};

const std::set<Tokenizer::Type> Tokenizer::OPERATORS = {
	OPERATOR_ADDITION, OPERATOR_SUBTRACTION, OPERATOR_MULTIPLICATION, OPERATOR_DIVISION, OPERATOR_MODULUS,
	OPERATOR_BITWISE_LEFT_SHIFT, OPERATOR_BITWISE_RIGHT_SHIFT, OPERATOR_BITWISE_XOR, OPERATOR_BITWISE_AND,
	OPERATOR_BITWISE_OR, OPERATOR_BITWISE_COMPLEMENT, OPERATOR_LOGICAL_NOT, OPERATOR_LOGICAL_EQUAL,
	OPERATOR_LOGICAL_NOT_EQUAL, OPERATOR_LOGICAL_LESS_THAN, OPERATOR_LOGICAL_GREATER_THAN,
	OPERATOR_LOGICAL_LESS_THAN_OR_EQUAL, OPERATOR_LOGICAL_GREATER_THAN_OR_EQUAL, OPERATOR_LOGICAL_OR,
	OPERATOR_LOGICAL_AND
};

const std::vector<std::pair<std::string, Tokenizer::Type>> Tokenizer::TOKEN_SPEC = {
	{"^:lo12:\\b", RELOCATION_EMU32_O_LO12}, {"^:hi20:\\b", RELOCATION_EMU32_ADRP_HI20},
	{"^:lo19:\\b", RELOCATION_EMU32_MOV_LO19}, {"^:hi13:\\b", RELOCATION_EMU32_MOV_HI13},

	{"^x0\\b", REGISTER_X0}, {"^x1\\b", REGISTER_X1},
	{"^x2\\b", REGISTER_X2}, {"^x3\\b", REGISTER_X3},
	{"^x4\\b", REGISTER_X4}, {"^x5\\b", REGISTER_X5},
	{"^x6\\b", REGISTER_X6}, {"^x7\\b", REGISTER_X7},
	{"^x8\\b", REGISTER_X8}, {"^x9\\b", REGISTER_X9},
	{"^x10\\b", REGISTER_X10}, {"^x11\\b", REGISTER_X11},
	{"^x12\\b", REGISTER_X12}, {"^x13\\b", REGISTER_X13},
	{"^x14\\b", REGISTER_X14}, {"^x15\\b", REGISTER_X15},
	{"^x16\\b", REGISTER_X16}, {"^x17\\b", REGISTER_X17},
	{"^x18\\b", REGISTER_X18}, {"^x19\\b", REGISTER_X19},
	{"^x20\\b", REGISTER_X20}, {"^x21\\b", REGISTER_X21},
	{"^x22\\b", REGISTER_X22}, {"^x23\\b", REGISTER_X23},
	{"^x24\\b", REGISTER_X24}, {"^x25\\b", REGISTER_X25},
	{"^x26\\b", REGISTER_X26}, {"^x27\\b", REGISTER_X27},
	{"^x28\\b", REGISTER_X28}, {"^x29\\b", REGISTER_X29},
	{"^xzr\\b", REGISTER_XZR}, {"^sp\\b", REGISTER_SP},

	{"^[a-zA-Z_][a-zA-Z0-9_]*:", LABEL},
	{"^ ", WHITESPACE_SPACE}, {"^\\t", WHITESPACE_TAB}, {"^\\n", WHITESPACE_NEWLINE},
	{"^[\\s^[ \\n\\t]]+", WHITESPACE},
	{"^;\\*[^*]*\\*+(?:[^;*][^*]*\\*+)*;", COMMENT_MULTI_LINE}, {"^;.*", COMMENT_SINGLE_LINE},
	{"^\\\\", BACK_SLASH}, {"^/", FORWARD_SLASH},
	{"^\\{", OPEN_BRACE}, {"^\\}", CLOSE_BRACE},
	{"^\\[", OPEN_BRACKET}, 	{"^\\]", CLOSE_BRACKET},
	{"^\\(", OPEN_PARANTHESIS},{"^\\)", CLOSE_PARANTHESIS},

	{"^#include\\b", PREPROCESSOR_INCLUDE},
	{"^#macro\\b", PREPROCESSOR_MACRO},
	{"^#macret\\b", PREPROCESSOR_MACRET},
	{"^#macend\\b", PREPROCESSOR_MACEND},
	{"^#invoke\\b", PREPROCESSOR_INVOKE},
	{"^#define\\b", PREPROCESSOR_DEFINE},
	{"^#undef\\b", PREPROCESSOR_UNDEF},
	{"^#ifdef\\b", PREPROCESSOR_IFDEF},
	{"^#ifndef\\b", PREPROCESSOR_IFNDEF},
	{"^#ifequ\\b", PREPROCESSOR_IFEQU},
	{"^#ifnequ\\b", PREPROCESSOR_IFNEQU},
	{"^#ifless\\b", PREPROCESSOR_IFLESS},
	{"^#ifmore\\b", PREPROCESSOR_IFMORE},
	{"^#else\\b", PREPROCESSOR_ELSE},
	{"^#elsedef\\b", PREPROCESSOR_ELSEDEF},
	{"^#elsendef\\b", PREPROCESSOR_ELSENDEF},
	{"^#elseequ\\b", PREPROCESSOR_ELSEEQU},
	{"^#elsenequ\\b", PREPROCESSOR_ELSENEQU},
	{"^#elseless\\b", PREPROCESSOR_ELSELESS},
	{"^#elsemore\\b", PREPROCESSOR_ELSEMORE},
	{"^#endif\\b", PREPROCESSOR_ENDIF},

	{"^\\.global\\b", ASSEMBLER_GLOBAL},
	{"^\\.extern\\b", ASSEMBLER_EXTERN},
	{"^\\.org\\b", ASSEMBLER_ORG},
	{"^\\.scope\\b", ASSEMBLER_SCOPE},
	{"^\\.scend\\b", ASSEMBLER_SCEND},
	{"^\\.ascii\\b", ASSEMBLER_ASCII},
	{"^\\.asciz\\b", ASSEMBLER_ASCIZ},
	{"^\\.advance\\b", ASSEMBLER_ADVANCE},
	{"^\\.fill\\b", ASSEMBLER_FILL},
	{"^\\.align\\b", ASSEMBLER_ALIGN},
	{"^\\.section\\b", ASSEMBLER_SECTION},
	{"^\\.bss\\b", ASSEMBLER_BSS},
	{"^\\.data\\b", ASSEMBLER_DATA},
	{"^\\.text\\b", ASSEMBLER_TEXT},
	{"^\\.stop\\b", ASSEMBLER_STOP},
	{"^\\.byte\\b", ASSEMBLER_BYTE},
	{"^\\.dbyte\\b", ASSEMBLER_DBYTE},
	{"^\\.word\\b", ASSEMBLER_WORD},
	{"^\\.dword\\b", ASSEMBLER_DWORD},
	{"^\\.sbyte\\b", ASSEMBLER_SBYTE},
	{"^\\.sdbyte\\b", ASSEMBLER_SDBYTE},
	{"^\\.sword\\b", ASSEMBLER_SWORD},
	{"^\\.sdword\\b", ASSEMBLER_SDWORD},

	{"^hlt\\b", INSTRUCTION_HLT},
	{"^add[s]?\\b", INSTRUCTION_ADD},
	{"^sub[s]?\\b", INSTRUCTION_SUB},
	{"^rsb[s]?\\b", INSTRUCTION_RSB},
	{"^adc[s]?\\b", INSTRUCTION_ADC},
	{"^sbc[s]?\\b", INSTRUCTION_SBC},
	{"^rsc[s]?\\b", INSTRUCTION_RSC},
	{"^mul[s]?\\b", INSTRUCTION_MUL},
	{"^umull[s]?\\b", INSTRUCTION_UMULL},
	{"^smull[s]?\\b", INSTRUCTION_SMULL},
	{"^vabs\\.f32\\b", INSTRUCTION_VABS_F32},
	{"^vneg\\.f32\\b", INSTRUCTION_VNEG_F32},
	{"^vsqrt\\.f32\\b", INSTRUCTION_VSQRT_F32},
	{"^vadd\\.f32\\b", INSTRUCTION_VADD_F32},
	{"^vsub\\.f32\\b", INSTRUCTION_VSUB_F32},
	{"^vdiv\\.f32\\b", INSTRUCTION_VDIV_F32},
	{"^vmul\\.f32\\b", INSTRUCTION_VMUL_F32},
	{"^vcmp\\.f32\\b", INSTRUCTION_VCMP_F32},
	{"^vsel\\.f32\\b", INSTRUCTION_VSEL_F32},
	{"^vcint\\.u32\\.f32\\b", INSTRUCTION_VCINT_U32_F32},
	{"^vcint\\.s32\\.f32\\b", INSTRUCTION_VCINT_S32_F32},
	{"^vcflo\\.u32\\.f32\\b", INSTRUCTION_VCFLO_U32_F32},
	{"^vcflo\\.s32\\.f32\\b", INSTRUCTION_VCFLO_S32_F32},
	{"^vmov\\.f32\\b", INSTRUCTION_VMOV_F32},
	{"^and[s]?\\b", INSTRUCTION_AND},
	{"^orr[s]?\\b", INSTRUCTION_ORR},
	{"^eor[s]?\\b", INSTRUCTION_EOR},
	{"^bic[s]?\\b", INSTRUCTION_BIC},
	{"^lsl[s]?\\b", INSTRUCTION_LSL},
	{"^lsr[s]?\\b", INSTRUCTION_LSR},
	{"^asr[s]?\\b", INSTRUCTION_ASR},
	{"^ror[s]?\\b", INSTRUCTION_ROR},
	{"^cmp\\b", INSTRUCTION_CMP},
	{"^cmn\\b", INSTRUCTION_CMN},
	{"^tst\\b", INSTRUCTION_TST},
	{"^teq\\b", INSTRUCTION_TEQ},
	{"^mov[s]?\\b", INSTRUCTION_MOV},
	{"^mvn[s]?\\b", INSTRUCTION_MVN},
	{"^ldr[s]?\\b", INSTRUCTION_LDR},
	{"^str[s]?\\b", INSTRUCTION_STR},
	{"^swp[s]?\\b", INSTRUCTION_SWP},
	{"^ldr[s]b?\\b", INSTRUCTION_LDRB},
	{"^str[s]b?\\b", INSTRUCTION_STRB},
	{"^swp[s]b?\\b", INSTRUCTION_SWPB},
	{"^ldr[s]h?\\b", INSTRUCTION_LDRH},
	{"^str[s]h?\\b", INSTRUCTION_STRH},
	{"^swp[s]h?\\b", INSTRUCTION_SWPH},
	{"^b\\b", INSTRUCTION_B},
	{"^bl\\b", INSTRUCTION_BL},
	{"^bx\\b", INSTRUCTION_BX},
	{"^blx\\b", INSTRUCTION_BLX},
	{"^swi\\b", INSTRUCTION_SWI},
	{"^adrp\\b", INSTRUCTION_ADRP},

	{"^ret\\b", INSTRUCTION_RET},

	{"^eq\\b", CONDITION_EQ}, {"^ne\\b", CONDITION_NE},
	{"^cs\\b", CONDITION_CS}, {"^hs\\b", CONDITION_HS},
	{"^cc\\b", CONDITION_CC}, {"^lo\\b", CONDITION_LO},
	{"^mi\\b", CONDITION_MI}, {"^pl\\b", CONDITION_PL},
	{"^vs\\b", CONDITION_VS}, {"^vc\\b", CONDITION_VC},
	{"^hi\\b", CONDITION_HI}, {"^ls\\b", CONDITION_LS},
	{"^ge\\b", CONDITION_GE}, {"^lt\\b", CONDITION_LT}, {"^gt\\b", CONDITION_GT}, {"^le\\b", CONDITION_LE},
	{"^al\\b", CONDITION_AL}, {"^nv\\b", CONDITION_NV},

	{"^#", NUMBER_SIGN},
	{"^[0-9]*\\.[0-9]+", LITERAL_FLOAT_32},
	{"^%[0-1]+", LITERAL_NUMBER_BINARY},
	{"^@[0-7]+", LITERAL_NUMBER_OCTAL},
	{"^[0-9]+", LITERAL_NUMBER_DECIMAL},
	{"^\\$[0-9a-fA-F]+", LITERAL_NUMBER_HEXADECIMAL},

	{"^\'.\'", LITERAL_CHAR}, {"^\".*\"", LITERAL_STRING},
	{"^[a-zA-Z_][a-zA-Z0-9_]*", SYMBOL},

	{"^,", COMMA}, {"^:", COLON}, {"^\\.", PERIOD}, {"^;", SEMICOLON},

	{"^\\+", OPERATOR_ADDITION}, {"^\\-", OPERATOR_SUBTRACTION},
	{"^\\*", OPERATOR_MULTIPLICATION}, {"^\\/", OPERATOR_DIVISION},
	{"^\\%", OPERATOR_MODULUS},
	{"^\\|\\|", OPERATOR_LOGICAL_OR}, {"^\\&\\&", OPERATOR_LOGICAL_AND},
	{"^\\<\\<", OPERATOR_BITWISE_LEFT_SHIFT}, {"^\\>\\>", OPERATOR_BITWISE_RIGHT_SHIFT},
	{"^\\^", OPERATOR_BITWISE_XOR}, {"^\\&", OPERATOR_BITWISE_AND},
	{"^\\|", OPERATOR_BITWISE_OR}, {"^~", OPERATOR_BITWISE_COMPLEMENT},
	{"^==", OPERATOR_LOGICAL_EQUAL}, {"^!=", OPERATOR_LOGICAL_NOT_EQUAL},
	{"^!", OPERATOR_LOGICAL_NOT},
	{"^\\<=", OPERATOR_LOGICAL_LESS_THAN_OR_EQUAL}, {"^\\>=", OPERATOR_LOGICAL_GREATER_THAN_OR_EQUAL},
	{"^\\<", OPERATOR_LOGICAL_LESS_THAN}, {"^\\>", OPERATOR_LOGICAL_GREATER_THAN},
};